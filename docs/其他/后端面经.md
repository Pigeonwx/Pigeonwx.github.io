# 前言

> 本文用于25年秋招后端开发岗位的复习
> 核心问题是对本人有用的问题

**每个面经的结构：问题概览+核心问题解析**

[TOC]
# 一、个人面经
> 本章梳理2024.08开始的面试问答
> 本人自身的面试经验
> 按照时间顺序进行整理

## 1.1 快手-一面

## 1.2 百度-移动生态数据部门-后端开发-一面

## 1.3 美团-核心到店部门-大模型后台开发-一面

## 1.4 快手-快手游戏-服务端开发-一面
1. 如何保证本地缓存和redis缓存的一致性

## 1.5 拼多多-多多买菜-服务端开发-一面

# 二、阿里Java岗
## 2.1 凌珂-阿里淘天java二面
>作者：凌珂
链接：https://www.nowcoder.com/interview/center?anchor=companyExp&checked=company&jumpFrom=%E6%9C%AA%E7%99%BB%E5%BD%95%E9%A6%96%E9%A1%B5
来源：牛客网

1. 工作中与同事发生冲突时如何解决？
2. 如何使用HashMap？
3. 如何快速开发一个类似淘宝的应用？
4. 平时如何学习深度学习？
5. 对计算机科学的理解，如何喜欢上计算机的？
6. 为什么选择读研，为什么选择出国读研？
7. 如果你是CTO，如何管理团队？
8. 为什么当初选择Golang而不是Java？
9. **协程适合IO密集型还是计算密集型任务？**
10. **设计一个朋友圈功能，从简单到复杂，如何设计数据库表？**
11. **用户量增加后如何处理？**
12. URL从按下回车到页面渲染的整个流程？
13. Redis和MySQL数据不一致如何解决？
14. **详细介绍B+树。**
15. 介绍自己的优势。
16. 如果现在不会Java，如何保证入职后快速上手？

---

**协程适合IO密集型还是计算密集型任务？**
**设计一个朋友圈功能，从简单到复杂，如何设计数据库表？**
**用户量增加后如何处理？**  
**详细介绍B+树？**

### 协程适合IO密集型还是计算密集型任务？

协程更适合IO密集型任务。协程是一种轻量级的线程，它们在执行IO操作时可以挂起自己，让出CPU资源给其他协程，从而提高系统的并发性能。对于IO密集型任务，协程可以有效地减少线程切换的开销，提高资源利用率和响应速度。而对于计算密集型任务，协程的优势不明显，因为计算密集型任务主要消耗CPU资源，协程的调度机制并不能显著提升性能。

### 设计一个朋友圈功能，从简单到复杂，如何设计数据库表？
- **简单设计**

1. **用户表（User）**
   ```sql
   CREATE TABLE User (
       user_id INT PRIMARY KEY,
       username VARCHAR(50),
       password VARCHAR(50),
       created_at TIMESTAMP
   );
   ```

2. **朋友圈表（Post）**
   ```sql
   CREATE TABLE Post (
       post_id INT PRIMARY KEY,
       user_id INT,
       content TEXT,
       created_at TIMESTAMP,
       FOREIGN KEY (user_id) REFERENCES User(user_id)
   );
   ```

### 复杂设计

1. **用户表（User）**
   ```sql
   CREATE TABLE User (
       user_id INT PRIMARY KEY,
       username VARCHAR(50),
       password VARCHAR(50),
       profile_picture VARCHAR(255),
       bio TEXT,
       created_at TIMESTAMP
   );
   ```

2. **朋友圈表（Post）**
   ```sql
   CREATE TABLE Post (
       post_id INT PRIMARY KEY,
       user_id INT,
       content TEXT,
       image_url VARCHAR(255),
       created_at TIMESTAMP,
       FOREIGN KEY (user_id) REFERENCES User(user_id)
   );
   ```

3. **评论表（Comment）**
   ```sql
   CREATE TABLE Comment (
       comment_id INT PRIMARY KEY,
       post_id INT,
       user_id INT,
       content TEXT,
       created_at TIMESTAMP,
       FOREIGN KEY (post_id) REFERENCES Post(post_id),
       FOREIGN KEY (user_id) REFERENCES User(user_id)
   );
   ```

4. **点赞表（Like）**
   ```sql
   CREATE TABLE Like (
       like_id INT PRIMARY KEY,
       post_id INT,
       user_id INT,
       created_at TIMESTAMP,
       FOREIGN KEY (post_id) REFERENCES Post(post_id),
       FOREIGN KEY (user_id) REFERENCES User(user_id)
   );
   ```

5. **好友关系表（Friendship）**
   ```sql
   CREATE TABLE Friendship (
       user_id INT,
       friend_id INT,
       created_at TIMESTAMP,
       PRIMARY KEY (user_id, friend_id),
       FOREIGN KEY (user_id) REFERENCES User(user_id),
       FOREIGN KEY (friend_id) REFERENCES User(user_id)
   );
   ```

### 用户量增加后如何处理？

1. **数据库分片和分区**：将数据库拆分成多个部分，分布在不同的服务器上，以减轻单个数据库的负载。
2. **缓存**：使用缓存系统（如Redis、Memcached）来存储频繁访问的数据，减少数据库的查询压力。
3. **负载均衡**：使用负载均衡器（如Nginx、HAProxy）将请求分发到多个服务器，均衡负载。
4. **垂直和水平扩展**：垂直扩展通过增加单个服务器的硬件资源（如CPU、内存），水平扩展通过增加更多的服务器来处理请求。
5. **异步处理**：将一些耗时的操作（如发送邮件、生成报告）放到后台异步处理，减少前端响应时间。
6. **优化查询**：通过优化SQL查询、添加索引等方式，提高数据库查询效率。

### 详细介绍B+树

B+树是一种自平衡的树数据结构，广泛应用于数据库和文件系统中。它是一种多路搜索树，具有以下特点：

1. **节点结构**：B+树的每个节点可以有多个子节点和多个键值。内部节点只存储键值和子节点指针，叶子节点存储实际数据和键值。
2. **平衡性**：B+树是自平衡的，所有叶子节点在同一层，树的高度保持在一个较低的水平，保证了查询、插入、删除操作的时间复杂度为O(log n)。
3. **顺序访问**：B+树的叶子节点通过指针相连，形成一个有序链表，方便顺序访问和范围查询。
4. **高效的磁盘读写**：B+树的节点大小通常与磁盘块大小相匹配，减少了磁盘I/O操作，提高了读写效率。

**B+树的操作**

1. **查找**：从根节点开始，逐层向下查找，直到找到目标键值或到达叶子节点。
2. **插入**：找到合适的叶子节点插入键值，如果节点满了，则进行分裂，分裂后的中间键值上升到父节点，可能引起父节点的分裂，递归进行。
3. **删除**：找到目标键值所在的叶子节点，删除键值，如果节点的键值数少于最小值，则进行合并或借用操作，可能引起父节点的调整，递归进行。

B+树通过其平衡性和高效的顺序访问特性，成为数据库索引和文件系统中常用的数据结构。

## 2.2 KingHaiYang-阿里橙狮体育JAVA实习一面
> 作者：KingHaiYang
链接：https://www.nowcoder.com/interview/center?anchor=companyExp&checked=company&jumpFrom=%E6%9C%AA%E7%99%BB%E5%BD%95%E9%A6%96%E9%A1%B5
来源：牛客网

1. 自我介绍
2. 线程的几种状态：（1）.新建（new）  （2）.就绪（runnable）（3）.运行（running）（4）.阻塞（block）1）等待阻塞 2）同步阻塞3）其他阻塞  （5）.死亡（dead）
3. 创建线程的方式3种：继承Thread类，实现Runable接口，实现Callable接口
4. ThreadLocal的理解：线程的变量副本，每个线程隔离
5. 线程池的核心参数有哪些：corePoolSize 线程池核心线程大小、maximumPoolSize 线程池最大线程数量、keepAliveTime 空闲线程存活时间、unit 空闲线程存活时间单位、workQueue 工作队列、threadFactory 线程工厂、handler 拒绝策略
6. MySQL索引的类型有哪些：主键、普通、全文、空间、唯一、前缀、组合
7. MySQL索引的存储结构有哪些：b树，b+树，二叉查找树，平衡二叉树
8. 覆盖索引和回表的理解
9. SQL执行计划主要看哪些信息
10. SQL优化：主键顺序插入
11. 为什么主键顺序插入会提高效率
12. select count(*) 和 select count(id)的区别
13. where后有两个条件，两个条件都分别创建了索引，优先使用哪个索引进行查询：哪个索引区分度大，筛选更快就使用哪个
14. Redis了解哪些
15. redis的穿透、击穿
16. redis是单线程的，为什么还快呢：（1）.redis是基于内存的，内存的读写速度非常快；（2）.redis是单线程的，省去了很多上下文切换线程的时间；（3）.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。
17. 项目中你觉得做的最好的点
18. 如何保证redis和MySQL的数据一致性
19. 使用redis的需要注意哪些：控制key的长度、避免存储bigkey、value的大小也要关注、string的大小控制在10kb以下，list、hash、set、zset也要控制、合理的选择数据类型、把redis尽可能的当成缓存使用、避免集中过期key等
20. 空间换时间，项目中的体现
21. 实现中两个项目上个项目和后边的项目在做的过程中有什么不一样的体会、
22. 消息队列的理解
23. 设计模式用过哪些
24. 反问：问的答得如何（前半部分基础达标了，后边深入原理的地方需要加强）


